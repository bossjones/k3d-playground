# Default values for Vector
# See Vector helm documentation to learn more:
# https://vector.dev/docs/setup/installation/package-managers/helm/

# nameOverride -- Override the name of resources.
nameOverride: ""

# fullnameOverride -- Override the full name of resources.
fullnameOverride: ""

# role -- [Role](https://vector.dev/docs/setup/deployment/roles/) for this Vector instance, valid options are:
# "Agent", "Aggregator", and "Stateless-Aggregator".

# Each role is created with the following workloads:
# Agent = DaemonSet
# Aggregator = StatefulSet
# Stateless-Aggregator = Deployment
role: "Agent"

# rollWorkload -- Add a checksum of the generated ConfigMap to workload annotations.
rollWorkload: true

# commonLabels -- Add additional labels to all created resources.
commonLabels: {}

# Define the Vector image to use.
image:
  # image.repository -- Override default registry and name for Vector's image.
  repository: timberio/vector
  # image.pullPolicy -- The [pullPolicy](https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy) for
  # Vector's image.
  pullPolicy: IfNotPresent
  # image.pullSecrets -- The [imagePullSecrets](https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod)
  # to reference for the Vector Pods.
  pullSecrets: []
  # image.tag -- The tag to use for Vector's image.
  # @default -- Derived from the Chart's appVersion.
  tag: ""
  # image.sha -- The SHA to use for Vector's image.
  sha: ""

# replicas -- Specify the number of Pods to create. Valid for the "Aggregator" and "Stateless-Aggregator" roles.
replicas: 1

# podManagementPolicy -- Specify the [podManagementPolicy](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-management-policies)
# for the StatefulSet. Valid for the "Aggregator" role.
podManagementPolicy: OrderedReady

# Create a Secret resource for Vector to use.
secrets:
  # secrets.generic -- Each Key/Value will be added to the Secret's data key, each value should be raw and NOT base64
  # encoded. Any secrets can be provided here. It's commonly used for credentials and other access related values.
  # **NOTE: Don't commit unencrypted secrets to git!**
  generic: {}
    # my_variable: "my-secret-value"
    # datadog_api_key: "api-key"
    # awsAccessKeyId: "access-key"
    # awsSecretAccessKey: "secret-access-key"

autoscaling:
  # autoscaling.enabled -- Create a [HorizontalPodAutoscaler](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
  # for Vector. Valid for the "Aggregator" and "Stateless-Aggregator" roles.
  enabled: false
  # autoscaling.annotations -- Annotations to add to Vector's HPA.
  annotations: {}
  # autoscaling.minReplicas -- Minimum replicas for Vector's HPA.
  minReplicas: 1
  # autoscaling.maxReplicas -- Maximum replicas for Vector's HPA.
  maxReplicas: 10
  # autoscaling.targetCPUUtilizationPercentage -- Target CPU utilization for Vector's HPA.
  targetCPUUtilizationPercentage: 80
  # autoscaling.targetMemoryUtilizationPercentage -- (int) Target memory utilization for Vector's HPA.
  targetMemoryUtilizationPercentage:
  # autoscaling.customMetric -- Target a custom metric for autoscaling.
  customMetric: {}
    #  - type: Pods
    #    pods:
    #      metric:
    #        name: utilization
    #      target:
    #        type: AverageValue
    #        averageValue: 95
  # autoscaling.behavior -- Configure separate scale-up and scale-down behaviors.
  behavior: {}
    # scaleDown:
    #   stabilizationWindowSeconds: 300

podDisruptionBudget:
  # podDisruptionBudget.enabled -- Enable a [PodDisruptionBudget](https://kubernetes.io/docs/tasks/run-application/configure-pdb/)
  # for Vector.
  enabled: false
  # podDisruptionBudget.minAvailable -- The number of Pods that must still be available after an eviction.
  minAvailable: 1
  # podDisruptionBudget.maxUnavailable -- (int) The number of Pods that can be unavailable after an eviction.
  maxUnavailable:

rbac:
  # rbac.create -- If true, create and use RBAC resources. Only valid for the "Agent" role.
  create: true

psp:
  # psp.create -- If true, create a [PodSecurityPolicy](https://kubernetes.io/docs/concepts/security/pod-security-policy/)
  # resource. PodSecurityPolicy is deprecated as of Kubernetes v1.21, and will be removed in v1.25. Intended for use
  # with the "Agent" role.
  create: false

serviceAccount:
  # serviceAccount.create -- If true, create a ServiceAccount for Vector.
  create: true
  # serviceAccount.annotations -- Annotations to add to Vector's ServiceAccount.
  annotations: {}
  # serviceAccount.name -- The name of the ServiceAccount to use. If not set and serviceAccount.create is true, a name
  # is generated using the fullname template.
  name:
  # serviceAccount.automountToken -- Automount API credentials for Vector's ServiceAccount.
  automountToken: true

# podAnnotations -- Set annotations on Vector Pods.
podAnnotations: {}

# podLabels -- Set labels on Vector Pods.
# podLabels:
#   vector.dev/exclude: "true"
# SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
# podLabels -- Set labels on Vector Pods.
podLabels:
  # this pod needs access to the api server
  # allow-apiserver-policy: "true"
  # allow-http-egress-policy: "true"
  vector.dev/exclude: "true"

# podPriorityClassName -- Set the [priorityClassName](https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass)
# on Vector Pods.
podPriorityClassName: ""

# podHostNetwork -- Configure hostNetwork on Vector Pods.
podHostNetwork: false

# podSecurityContext -- Allows you to overwrite the default [PodSecurityContext](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
# for Vector Pods.
podSecurityContext: {}

# workloadResourceAnnotations -- Set annotations on the Vector DaemonSet, Deployment or StatefulSet.
workloadResourceAnnotations: {}

# securityContext -- Specify securityContext on Vector containers.
securityContext: {}

# command -- Override Vector's default command.
command: []

# args -- Override Vector's default arguments.
args:
  - --config-dir
  - "/etc/vector/"

# env -- Set environment variables for Vector containers.
env: []
  # - name: MY_VARIABLE
  #   valueFrom:
  #     secretKeyRef:
  #       name: vector
  #       key: my_variable
  # - name: AWS_ACCESS_KEY_ID
  #   valueFrom:
  #     secretKeyRef:
  #       name: vector
  #       key: awsAccessKeyId

# envFrom -- Define environment variables from Secrets or ConfigMaps.
envFrom: []
  # - secretRef:
  #     name: vector

# containerPorts -- Manually define Vector's containerPorts, overriding automated generation of containerPorts.
containerPorts: []

# resources -- Set Vector resource requests and limits.
resources:
  requests:
    memory: "256Mi"
    cpu: "300m"
  limits:
    memory: "500Mi"
    cpu: "400m"

# lifecycle -- Set lifecycle hooks for Vector containers.
lifecycle: {}
  # preStop:
  #   exec:
  #     command:
  #     - /bin/sleep
  #     - "10"


# minReadySeconds -- Specify the minimum number of seconds a newly spun up DaemonSet pod should wait to
# pass healthchecks before it is considered available.
minReadySeconds: 0

# updateStrategy -- Customize the updateStrategy used to replace Vector Pods, this is also used for the
# DeploymentStrategy for the "Stateless-Aggregators". Valid options depend on the chosen role.

# Agent (DaemonSetUpdateStrategy): https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec)
# Aggregator (StatefulSetUpdateStrategy): https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec
# Stateless-Aggregator (DeploymentStrategy): https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/
updateStrategy: {}
#   type: RollingUpdate
#   rollingUpdate:
#     maxUnavailable: 1

# terminationGracePeriodSeconds -- Override Vector's terminationGracePeriodSeconds.
terminationGracePeriodSeconds: 60

# nodeSelector -- Configure a [nodeSelector](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
# for Vector Pods.
nodeSelector: {}

# tolerations -- Configure Vector Pods to be scheduled on [tainted](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
# nodes.
tolerations: []

# affinity -- Configure [affinity](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)
# rules for Vector Pods.
affinity: {}

# topologySpreadConstraints -- Configure [topology spread constraints](https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/)
# for Vector Pods. Valid for the "Aggregator" and "Stateless-Aggregator" roles.
topologySpreadConstraints: []

# Configuration for Vector's Service.
service:
  # service.enabled -- If true, create and provide a Service resource for Vector.
  enabled: true
  # service.type -- Set the type for Vector's Service.
  type: "ClusterIP"
  # service.annotations -- Set annotations on Vector's Service.
  annotations: {}
  # service.topologyKeys -- Specify the [topologyKeys](https://kubernetes.io/docs/concepts/services-networking/service-topology/#using-service-topology)
  # field on Vector's Service.
  topologyKeys: []
  #   - "kubernetes.io/hostname"
  #   - "topology.kubernetes.io/zone"
  #   - "topology.kubernetes.io/region"
  #   - "*"
  # service.ports -- Manually set the Service ports, overriding automated generation of Service ports.
  ports:
    - name: http
      port: 9090
  # service.externalTrafficPolicy -- Specify the [externalTrafficPolicy](https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip).
  externalTrafficPolicy: ""
  # service.internalTrafficPolicy -- Specify the [internalTrafficPolicy]https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy).
  internalTrafficPolicy: ""
  # service.loadBalancerIP -- Specify the [loadBalancerIP](https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer).
  loadBalancerIP: ""
  # service.ipFamilyPolicy -- Configure [IPv4/IPv6 dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/).
  ipFamilyPolicy: ""
  # service.ipFamilies -- Configure [IPv4/IPv6 dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/).
  ipFamilies: []

# Configuration for Vector's Headless Service.
serviceHeadless:
  # serviceHeadless.enabled -- If true, create and provide a Headless Service resource for Vector.
  enabled: true

# Configuration for Vector's Ingress.
ingress:
  # ingress.enabled -- If true, create and use an Ingress resource.
  enabled: true
  # ingress.className -- Specify the [ingressClassName](https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress),
  # requires Kubernetes >= 1.18
  className: "nginx"
  # ingress.annotations -- Set annotations on the Ingress.
  annotations:
    ingress.kubernetes.io/ssl-redirect: "false"
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # ingress.hosts -- Configure the hosts and paths for the Ingress.
  # hosts: []
  hosts:
      - host: vector.k8s.localhost
        paths:
          - path: /
            pathType: Prefix
            # Specify the port name or number on the Service
            # Using name requires Kubernetes >=1.19
            port:
              name: "http"
              number: "9090"

  #  - host: chart-example.local
  #    paths:
  #      - path: /
  #        pathType: ImplementationSpecific
  #        # Specify the port name or number on the Service
  #        # Using name requires Kubernetes >=1.19
  #        port:
  #          name: ""
  #          number: ""
  # ingress.tls -- Configure TLS for the Ingress.
  tls:
  - secretName: tls-secret
    hosts:
    - vector.k8s.localhost
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# existingConfigMaps -- List of existing ConfigMaps for Vector's configuration instead of creating a new one. Requires
# dataDir to be set. Additionally, containerPorts, service.ports, and serviceHeadless.ports should be specified based on
# your supplied configuration. If set, this parameter takes precedence over customConfig and the chart's default configs.
existingConfigMaps: []

# dataDir -- Specify the path for Vector's data, only used when existingConfigMaps are used.
dataDir: ""

# customConfig -- Override Vector's default configs, if used **all** options need to be specified. This section supports
# using helm templates to populate dynamic values. See Vector's [configuration documentation](https://vector.dev/docs/reference/configuration/)
# for all options.

customConfig:
  data_dir: /var/lib/vector
  api:
    enabled: true
    address: 0.0.0.0:8686
    playground: false
  sources:
    # SOURCE: https://medium.com/@guilmont.romain/observing-k8s-events-in-grafana-an-easy-way-a47efcb395c1
    kubernetes_events:
      type: kubernetes_logs
      # Select only the k8s-event-logger pod
      extra_label_selector: "app.kubernetes.io/name=k8s-event-logger"
    kubernetes_logs:
      type: kubernetes_logs
      read_from: end
    host_metrics:
      filesystem:
        devices:
          excludes: [binfmt_misc]
        filesystems:
          excludes: [binfmt_misc]
        mountPoints:
          excludes: ["*/proc/sys/fs/binfmt_misc"]
      type: host_metrics
    internal_metrics:
      type: internal_metrics
  # sources:
  #   kube_log:
  #     type: "kubernetes_logs"
  #     timezone: "local"
  #     auto_partial_merge: true
  #     extra_namespace_label_selector: "kubernetes.io/metadata.name in (monitoring)"
  transforms:
    # SOURCE: https://medium.com/@guilmont.romain/observing-k8s-events-in-grafana-an-easy-way-a47efcb395c1
    parse_k8s_events:
      inputs:
        - kubernetes_events
      type: remap
      source: |
        # Remove useless fields. In this case, we are only interested
        # about the output of the application, we don't want to monitor
        # the pod itself
              del(.kubernetes)
              parsed, err = parse_json(string!(.message))
              if err != null {
                .log_parsing_error = err
              } else {
                . |= object!(parsed)
              }


      # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
      kubernetes_strip_ansi:
        type: remap
        inputs:
          - kubernetes_logs
        source: |
          .message = strip_ansi_escape_codes(string!(.message))

      kubernetes_parse_filter_annotation:
        type: remap
        inputs:
          - kubernetes_strip_ansi
        source: |
          if (is_null(.filtered) && !is_null(.kubernetes.pod_annotations) && !is_empty(object!(.kubernetes.pod_annotations)) && is_string(.message)) {
            message_str, msg_err = string(.message)
            if (is_null(msg_err)) {
              filtered = false
              for_each(object!(.kubernetes.pod_annotations)) -> |annotation, value| {
                if !filtered && contains(string(annotation), "filter.kube.logging.io/") {
                  parts = split(annotation, ".")
                  if (length(parts) == 6) {
                    stream = parts[0]
                    container = parts[1]
                    if (stream == .stream && container == .kubernetes.container_name) {
                      pattern_str, err = string(value)
                      if (is_null(err)) {
                        pattern, err = to_regex(pattern_str)
                        if (is_null(err) && match(message_str, pattern)) {
                          filtered = true
                        }
                      }
                    }
                  }
                }
              }

              .filtered = filtered
            }
          }

      kubernetes_filter:
        type: filter
        inputs:
          - kubernetes_parse_filter_annotation
        condition:
          type: vrl
          source: |
            (is_null(.filtered) || !to_bool!(.filtered)) && !is_empty(strip_whitespace(string!(.message)))

      kubernetes_standardize_app:
        type: remap
        inputs:
          - kubernetes_filter
        source: |
          # Standardize 'app' index
          .custom_app_name = .kubernetes.pod_labels."app.kubernetes.io/name" || .kubernetes.pod_labels.app || .kubernetes.pod_labels."k8s-app" || "unknown"


          # Since we have 2 different sources, need to include this by default
          .node = .kubernetes.pod_node_name
          .pod = .kubernetes.pod_name
          .namespace = .kubernetes.pod_namespace
          .container = .kubernetes.container_name

  # transforms:
  #   my_remap_id:
  #     type: remap
  #     inputs:
  #     - kubernetes_logs
  #     source: |-
  #       .test = del(.)
  #       .container_name = del(.test.kubernetes.container_name)
  #       .message = del(.test.message)
  #       .timestamp = del(.test.timestamp)
  #       del(.test)

  sinks:
    # azure_blob:
    #   type: azure_blob
    #   inputs:
    #     - my_remap_id
    #   connection_string: ""
    #   container_name: akslogs
    #   blob_prefix: |-
    #     {{print "%Y%m%d/{{ container_name }}/"}}
    #   blob_append_uuid: true
    #   compression: none
    #   encoding:
    #     codec: json
    prom_exporter:
      type: prometheus_exporter
      inputs: [host_metrics, internal_metrics]
      address: 0.0.0.0:9090
    stdout:
      type: console
      inputs: [kubernetes_standardize_app]
      encoding:
        codec: json
# https://vector.dev/docs/reference/configuration/sinks/loki/#label-expansion
    loki:
      type: loki
      inputs:
        # - "my_remap_id"
        - "parse_k8s_events"
        - "kubernetes_standardize_app"
      # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
      batch:
        max_bytes: 2049000
      endpoint: http://loki-loki-distributed-gateway.monitoring.svc.cluster.local
      labels:
        forwarder: vector
        cluster: k3d
        host: "k3d-playground"
        job: vector
        application: "vector"
        # SOURCE: https://github.com/helm/helm/issues/2798
        # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
        # app: "`{{ custom_app_name }}`"
        # stream: "`{{ stream  }}`"
        # node: "`{{ kubernetes.pod_node_name  }}`"
        # pod: "`{{ kubernetes.pod_name  }}`"
        # namespace: "`{{ kubernetes.pod_namespace }}`"
        # container: "`{{ kubernetes.container_name }}`"

        # ############################################################
        # #YAML
        # ############################################################
        # Block Scalars
        # A block scalar header has three parts:

        # Block Style Indicator: The block style indicates how newlines inside the block should behave. If you would like them to be kept as newlines, use the literal style, indicated by a pipe (|). If instead you want them to be replaced by spaces, use the folded style, indicated by a right angle bracket (>). (To get a newline using the folded style, leave a blank line by putting two newlines in. Lines with extra indentation are also not folded.)

        # Block Chomping Indicator: The chomping indicator controls what should happen with newlines at the end of the string. The default, clip, puts a single newline at the end of the string. To remove all newlines, strip them by putting a minus sign (-) after the style indicator. Both clip and strip ignore how many newlines are actually at the end of the block; to keep them all put a plus sign (+) after the style indicator.

        #Below key useed printf() to escape Helm interprets {{ }}
        # SOURCE: https://github.com/helm/helm/issues/2798#issuecomment-890478869
        app:  >-
          {{ printf "{{ custom_app_name }}" }}
        stream: >-
          {{ printf "{{ stream }}" }}
        # node:  >-
        #   {{ printf "{{ kubernetes.pod_node_name }}" }}
        # pod:  >-
        #   {{ printf "{{ kubernetes.pod_name }}" }}
        # namespace:  >-
        #   {{ printf "{{ kubernetes.pod_namespace }}" }}
        # container:  >-
        #   {{ printf "{{ kubernetes.container_name }}" }}
        source: kubernetes
        ############################################################################
      out_of_order_action: accept
      remove_timestamp: true
      # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
      remove_label_fields: true
      tenant_id: docker
      healthcheck:
        enabled: true
      request:
        concurrency: "adaptive"
        rate_limit_duration_secs: 1
        rate_limit_num: 10
      encoding:
        codec: "json"
        timestamp_format: "rfc3339"
        # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
        except_fields:
          # - file
          # - kubernetes.container_id
          # - kubernetes.container_image
          - kubernetes.namespace_labels."kubernetes.io/metadata.name"
          # - kubernetes.node_labels
          # - kubernetes.pod_ip
          # - kubernetes.pod_ips
          # - kubernetes.pod_owner
          # - kubernetes.pod_uid
          # - kubernetes.pod_name
          # - kubernetes.pod_namespace
          # - kubernetes.container_name
          # - kubernetes.pod_annotations
          # - kubernetes.container_name
          - kubernetes.pod_labels."app.kubernetes.io/managed-by"
          - kubernetes.pod_labels."controller-revision-hash"
          - kubernetes.pod_labels."pod-template-generation"
          - kubernetes.pod_labels."pod-template-hash"
          # - source_type
          # - stream
          # - timestamp_end
        only_fields:
          - kubernetes.namespace_labels
          - kubernetes.pod_labels
          - message
          # - geoip
          - src_ip
          - parsed
      auth:
        strategy: "basic"
        user: ""
        password: ""

  # data_dir: /vector-data-dir
  # api:
  #   enabled: true
  #   address: 127.0.0.1:8686
  #   playground: false
  # sources:
  #   vector:
  #     address: 0.0.0.0:6000
  #     type: vector
  #     version: "2"
  # sinks:
  #   stdout:
  #     type: console
  #     inputs: [vector]
  #     encoding:
  #       codec: json

# defaultVolumes -- Default volumes that are mounted into pods. In most cases, these should not be changed.
# Use `extraVolumes`/`extraVolumeMounts` for additional custom volumes.
# @default -- See `values.yaml`
defaultVolumes:
  - name: var-log
    hostPath:
      path: "/var/log/"
  - name: var-lib
    hostPath:
      path: "/var/lib/"
  - name: procfs
    hostPath:
      path: "/proc"
  - name: sysfs
    hostPath:
      path: "/sys"

# defaultVolumeMounts -- Default volume mounts. Corresponds to `volumes`.
# @default -- See `values.yaml`
defaultVolumeMounts:
  - name: var-log
    mountPath: "/var/log/"
    readOnly: true
  - name: var-lib
    mountPath: "/var/lib"
    readOnly: true
  - name: procfs
    mountPath: "/host/proc"
    readOnly: true
  - name: sysfs
    mountPath: "/host/sys"
    readOnly: true

# extraVolumes -- Additional Volumes to use with Vector Pods.
extraVolumes: []

# extraVolumeMounts -- Additional Volume to mount into Vector Containers.
extraVolumeMounts: []

# initContainers -- Init Containers to be added to the Vector Pods.
initContainers: []

# extraContainers -- Extra Containers to be added to the Vector Pods.
extraContainers: []

# Configuration for Vector's data persistence.
persistence:
  # persistence.enabled -- If true, create and use PersistentVolumeClaims.
  enabled: false
  # persistence.existingClaim -- Name of an existing PersistentVolumeClaim to use. Valid for the "Aggregator" role.
  existingClaim: ""
  # persistence.storageClassName -- Specifies the storageClassName for PersistentVolumeClaims. Valid for the
  # "Aggregator" role.
  # storageClassName: default

  # persistence.accessModes -- Specifies the accessModes for PersistentVolumeClaims. Valid for the "Aggregator" role.
  accessModes:
    - ReadWriteOnce
  # persistence.size -- Specifies the size of PersistentVolumeClaims. Valid for the "Aggregator" role.
  size: 10Gi
  # persistence.finalizers -- Specifies the finalizers of PersistentVolumeClaims. Valid for the "Aggregator" role.
  finalizers:
    - kubernetes.io/pvc-protection
  # persistence.selectors -- Specifies the selectors for PersistentVolumeClaims. Valid for the "Aggregator" role.
  selectors: {}

  hostPath:
    # persistence.hostPath.enabled -- If true, use hostPath persistence. Valid for the "Agent" role, if it's disabled
    # the "Agent" role will use emptyDir.
    enabled: true
    # persistence.hostPath.path -- Override path used for hostPath persistence. Valid for the "Agent" role, persistence
    # is always used for the "Agent" role.
    path: "/var/lib/vector"

# dnsPolicy -- Specify the [dnsPolicy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy)
# for Vector Pods.
dnsPolicy: ClusterFirst

# dnsConfig -- Specify the [dnsConfig](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config)
# options for Vector Pods.
dnsConfig: {}
  # nameservers:
  #   - 1.2.3.4
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

# shareProcessNamespace -- Specify the [shareProcessNamespace](https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/)
# options for Vector Pods.
shareProcessNamespace: false

# livenessProbe -- Override default liveness probe settings. If customConfig is used, requires customConfig.api.enabled
# to be set to true.
livenessProbe: {}
  # httpGet:
  #   path: /health
  #   port: api

# readinessProbe -- Override default readiness probe settings. If customConfig is used,
# requires customConfig.api.enabled to be set to true.
readinessProbe: {}
  # httpGet:
  #   path: /health
  #   port: api

# Configure a PodMonitor for Vector, requires the PodMonitor CRD to be installed.
podMonitor:
  # podMonitor.enabled -- If true, create a PodMonitor for Vector.
  enabled: true
  # podMonitor.jobLabel -- Override the label to retrieve the job name from.
  jobLabel: app.kubernetes.io/name
  # podMonitor.port -- Override the port to scrape.
  port: prom-exporter
  # podMonitor.path -- Override the path to scrape.
  path: /metrics
  # podMonitor.interval -- Override the interval at which metrics should be scraped.
  interval:
  # podMonitor.scrapeTimeout -- Override the timeout after which the scrape is ended.
  scrapeTimeout:
  # podMonitor.relabelings -- [RelabelConfigs](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config)
  # to apply to samples before scraping.
  relabelings: []
  # podMonitor.metricRelabelings -- [MetricRelabelConfigs](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs)
  # to apply to samples before ingestion.
  # metricRelabelings: []
  # podMonitor.metricRelabelings -- [MetricRelabelConfigs](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs)
  # to apply to samples before ingestion
  # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
  metricRelabelings:
    # Drop metrics that are unset, high cardinality, or extraneous
    - sourceLabels: [__name__]
      action: drop
      regex: ^vector_files_.*
    - sourceLabels: [__name__]
      action: drop
      regex: ^vector_checksum_.*
  # podMonitor.additionalLabels -- Adds additional labels to the PodMonitor.
  # podMonitor.podTargetLabels -- [podTargetLabels](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.PodMonitorSpec)
  # transfers labels on the Kubernetes Pod onto the target.
  podTargetLabels: []
  # podMonitor.additionalLabels -- Adds additional labels to the PodMonitor.
  # additionalLabels: {}
  # SOURCE: https://github.com/home-prod/k8s-infra/blob/82cbe52ba47597b52a7fc03eee4d1b526beab836/kubernetes/charts/infra/charts/logging/charts/vector/templates/vector-application.yaml
  additionalLabels:
    prometheus: main
  # podMonitor.honorLabels -- If true, honor_labels is set to true in the [scrape config](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config).
  honorLabels: false
  # podMonitor.honorTimestamps -- If true, honor_timestamps is set to true in the [scrape config](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config).
  honorTimestamps: true

# Log level for Vector.
logLevel: "debug"

# Optional built-in HAProxy load balancer.
haproxy:
  # haproxy.enabled -- If true, create a HAProxy load balancer.
  enabled: false

  # Define the HAProxy image to use.
  image:
    # haproxy.image.repository -- Override default registry and name for HAProxy.
    repository: haproxytech/haproxy-alpine
    # haproxy.image.pullPolicy -- HAProxy image pullPolicy.
    pullPolicy: IfNotPresent
    # haproxy.image.pullSecrets -- The [imagePullSecrets](https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod)
    # to reference for the HAProxy Pods.
    pullSecrets: []
    # haproxy.image.tag -- The tag to use for HAProxy's image.
    tag: "2.6.12"

  # haproxy.rollWorkload -- Add a checksum of the generated ConfigMap to the HAProxy Deployment.
  rollWorkload: true

  # haproxy.replicas -- Set the number of HAProxy Pods to create.
  replicas: 1

  serviceAccount:
    # haproxy.serviceAccount.create -- If true, create a HAProxy ServiceAccount.
    create: true
    # haproxy.serviceAccount.annotations -- Annotations to add to the HAProxy ServiceAccount.
    annotations: {}
    # haproxy.serviceAccount.name -- The name of the HAProxy ServiceAccount to use. If not set and create is true, a
    # name is generated using the fullname template.
    name:
    # haproxy.serviceAccount.automountToken -- Automount API credentials for the HAProxy ServiceAccount.
    automountToken: true

  # haproxy.strategy -- Customize the [strategy](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/)
  # used to replace HAProxy Pods.
  strategy: {}
    # rollingUpdate:
    #   maxSurge: 25%
    #   maxUnavailable: 25%
    # type: RollingUpdate

  # haproxy.terminationGracePeriodSeconds -- Override HAProxy's terminationGracePeriodSeconds.
  terminationGracePeriodSeconds: 60

  # haproxy.podAnnotations -- Set annotations on HAProxy Pods.
  podAnnotations: {}

  # haproxy.podLabels -- Set labels on HAProxy Pods.
  podLabels: {}

  # haproxy.podPriorityClassName -- Set the priorityClassName on HAProxy Pods.
  podPriorityClassName: ""

  # haproxy.podSecurityContext -- Allows you to overwrite the default PodSecurityContext for HAProxy.
  podSecurityContext: {}
    # fsGroup: 2000

  # haproxy.securityContext -- Specify securityContext on HAProxy containers.
  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  # haproxy.containerPorts -- Manually define HAProxy's containerPorts, overrides automated generation of containerPorts.
  containerPorts: []

  # HAProxy's Service configuration.
  service:
    # haproxy.service.type -- Set type of HAProxy's Service.
    type: ClusterIP
    # haproxy.service.annotations -- Set annotations on HAProxy's Service.
    annotations: {}
    # haproxy.service.topologyKeys -- Specify the [topologyKeys](https://kubernetes.io/docs/concepts/services-networking/service-topology/#using-service-topology)
    # field on HAProxy's Service spec.
    topologyKeys: []
    #   - "kubernetes.io/hostname"
    #   - "topology.kubernetes.io/zone"
    #   - "topology.kubernetes.io/region"
    #   - "*"
    # haproxy.service.ports -- Manually set HAPRoxy's Service ports, overrides automated generation of Service ports.
    ports: []
    # haproxy.service.externalTrafficPolicy -- Specify the [externalTrafficPolicy](https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip).
    externalTrafficPolicy: ""
    # haproxy.service.loadBalancerIP -- Specify the [loadBalancerIP](https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer).
    loadBalancerIP: ""
    # haproxy.service.ipFamilyPolicy -- Configure [IPv4/IPv6 dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/).
    ipFamilyPolicy: ""
    # haproxy.service.ipFamilies -- Configure [IPv4/IPv6 dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/).
    ipFamilies: []

  # haproxy.existingConfigMap -- Use this existing ConfigMap for HAProxy's configuration instead of creating a new one.
  # Additionally, haproxy.containerPorts and haproxy.service.ports should be specified based on your supplied
  # configuration. If set, this parameter takes precedence over customConfig and the chart's default configs.
  existingConfigMap: ""

  # haproxy.customConfig -- Override HAProxy's default configs, if used **all** options need to be specified.
  # This parameter supports using Helm templates to insert values dynamically. By default, this chart will parse
  # Vector's configuration from customConfig to generate HAProxy's config, which can be overwritten with
  # haproxy.customConfig.
  customConfig: ""

  # haproxy.extraVolumes -- Additional Volumes to use with HAProxy Pods.
  extraVolumes: []

  # haproxy.extraVolumeMounts -- Additional Volume to mount into HAProxy Containers.
  extraVolumeMounts: []

  # haproxy.initContainers -- Init Containers to be added to the HAProxy Pods.
  initContainers: []

  # haproxy.extraContainers -- Extra Containers to be added to the HAProxy Pods.
  extraContainers: []

  autoscaling:
    # haproxy.autoscaling.enabled -- Create a HorizontalPodAutoscaler for HAProxy.
    enabled: false
    # haproxy.autoscaling.minReplicas -- Minimum replicas for HAProxy's HPA.
    minReplicas: 1
    # haproxy.autoscaling.maxReplicas -- Maximum replicas for HAProxy's HPA.
    maxReplicas: 10
    # haproxy.autoscaling.targetCPUUtilizationPercentage -- Target CPU utilization for HAProxy's HPA.
    targetCPUUtilizationPercentage: 80
    # haproxy.autoscaling.targetMemoryUtilizationPercentage -- (int) Target memory utilization for HAProxy's HPA.
    targetMemoryUtilizationPercentage:
    # haproxy.autoscaling.customMetric -- Target a custom metric for autoscaling.
    customMetric: {}
      #  - type: Pods
      #    pods:
      #      metric:
      #        name: utilization
      #      target:
      #        type: AverageValue
      #        averageValue: 95

  # haproxy.resources -- Set HAProxy resource requests and limits.
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # haproxy.livenessProbe -- Override default HAProxy liveness probe settings.
  livenessProbe:
    tcpSocket:
      port: 1024

  # haproxy.readinessProbe -- Override default HAProxy readiness probe settings.
  readinessProbe:
    tcpSocket:
      port: 1024

  # haproxy.nodeSelector -- Configure a [nodeSelector](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
  # for HAProxy Pods
  nodeSelector: {}

  # haproxy.tolerations -- Configure HAProxy Pods to be scheduled on [tainted](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
  # nodes.
  tolerations: []

  # haproxy.affinity -- Configure [affinity](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)
  # rules for HAProxy Pods.
  affinity: {}

# extraObjects -- Create extra manifests via values. Would be passed through `tpl` for templating.
extraObjects: []
  # - apiVersion: v1
  #   kind: ConfigMap
  #   metadata:
  #     name: vector-dashboards
  #     labels:
  #       grafana_dashboard: "1"
  #   data:
  #     vector.json: |
  #       {{ .Files.Get "dashboards/vector.json" | fromJson | toJson }}
