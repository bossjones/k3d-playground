# ---
# Copyright (C) Nicolas Lamirault <nicolas.lamirault@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

ingress:
  enabled: true
  entries:
  - name: argo-workflows-external
    host: argo-workflows.k8s.localhost
    className: nginx
    annotations:
      hajimari.io/enable: "true"
      hajimari.io/icon: "logos:argo-icon"
      hajimari.io/appName: "Argo Workflows"
      hajimari.io/group: "Gitops"
    labels: {}
  # - name: argo-workflows-cloudflare
  #   host: argo-workflows.homelab.k3s.portefaix.xyz
  #   className: nginx
  #   annotations:
  #     external-dns.alpha.kubernetes.io/hostname: argo-workflows.homelab.k3s.portefaix.xyz
  #     nginx.ingress.kubernetes.io/auth-url: |-
  #       http://authentik.identity.svc.cluster.local/outpost.goauthentik.io/auth/nginx
  #     nginx.ingress.kubernetes.io/auth-signin: |-
  #       http://authentik.homelab.k3s.portefaix.xyz/outpost.goauthentik.io/start?rd=$escaped_request_uri
  #     nginx.ingress.kubernetes.io/auth-response-headers: |-
  #       Set-Cookie,X-authentik-username,X-authentik-groups,X-authentik-email,X-authentik-name,X-authentik-uid
  #     nginx.ingress.kubernetes.io/auth-snippet: |
  #       proxy_set_header X-Forwarded-Host $http_host;
  #   labels:
  #     external-dns.io/provider: cloudflare

# NOTE: This is the section that is duplicated it seems
argo-workflows:
  controller:
    parallelism: 2
    resourceRateLimit:
      limit: 5
      burst: 1
    workflowWorkers: 2
    podWorkers: 2
    resources:
      limits:
        cpu: 4
        memory: 1Gi
      requests:
        cpu: 200m
        memory: 256Mi

  mainContainer:
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 200m
        memory: 256Mi

  executor:
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 200m
        memory: 256Mi

  server:
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 200m
        memory: 256Mi
    ingress:
      enabled: true
      ingressClassName: nginx
      # annotations:
      #   nginx.ingress.kubernetes.io/auth-url: |-
      #     http://authentik.identity.svc.cluster.local:9000/outpost.goauthentik.io/auth/nginx
      #   nginx.ingress.kubernetes.io/auth-signin: |-
      #     https://auth.homelab.portefaix.xyz/outpost.goauthentik.io/start?rd=$escaped_request_uri
      #   nginx.ingress.kubernetes.io/auth-response-headers: |-
      #     Set-Cookie,X-authentik-username,X-authentik-uid
      #   nginx.ingress.kubernetes.io/auth-snippet: |
      #     proxy_set_header X-Forwarded-Host $http_host;
      hosts:
      - argo.k8s.localhost
      paths:
      - /
      pathType: Prefix

    extraArgs: []
    # - --auth-mode=sso
    # - server
    # - --namespaced
    # - --auth-mode=server
    # - server
    # - --auth-mode=client
    # - client
    # -  --loglevel=debug
    sso:
      issuer: http://dex:5556/dex
      sessionExpiry: 240h
      clientId:
        name: argo-server-sso
        key: clientID
      clientSecret:
        name: argo-server-sso
        key: clientSecret
      redirectUrl: http://argo.k8s.localhost/oauth2/callback
      scopes:
      - groups
      # - email
      # - profile
      rbac:
        enabled: true
      # issuer: http://argocd.k8s.localhost/api/dex
      # sessionExpiry: 240h
      # clientId:
      #   name: argo-workflows-dex
      #   key: client-id
      # clientSecret:
      #   name: argo-workflows-dex
      #   key: client-secret
      # redirectUrl: http://argo-workflows.k8s.localhost/oauth2/callback
      # rbac:
      #   enabled: true
      # scopes:
      # - groups

#################################################################################

images:
  # -- Common tag for Argo Workflows images. Defaults to `.Chart.AppVersion`.
  tag: ""
  # -- imagePullPolicy to apply to all containers
  pullPolicy: IfNotPresent
  # -- Secrets with credentials to pull images from a private registry
  pullSecrets: []
  # - name: argo-pull-secret

## Custom resource configuration
crds:
  # -- Install and upgrade CRDs
  install: true
  # -- Keep CRDs on chart uninstall
  keep: true
  # -- Annotations to be added to all CRDs
  annotations: {}

# -- Create clusterroles that extend existing clusterroles to interact with argo-cd crds
## Ref: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#aggregated-clusterroles
createAggregateRoles: true

# -- String to partially override "argo-workflows.fullname" template
nameOverride:

# -- String to fully override "argo-workflows.fullname" template
fullnameOverride:

# -- Labels to set on all resources
commonLabels: {}

# -- Override the Kubernetes version, which is used to evaluate certain manifests
kubeVersionOverride: ""

# Override APIVersions
apiVersionOverrides:
  # -- String to override apiVersion of autoscaling rendered by this helm chart
  autoscaling: "" # autoscaling/v2
  # -- String to override apiVersion of GKE resources rendered by this helm chart
  cloudgoogle: "" # cloud.google.com/v1

# -- Restrict Argo to operate only in a single namespace (the namespace of the
# Helm release) by apply Roles and RoleBindings instead of the Cluster
# equivalents, and start workflow-controller with the --namespaced flag. Use it
# in clusters with strict access policy.
singleNamespace: true

workflow:
  # -- Deprecated; use controller.workflowNamespaces instead.
  namespace:
  serviceAccount:
    # -- Specifies whether a service account should be created
    create: true
    # -- Labels applied to created service account
    labels: {}
    # -- Annotations applied to created service account
    annotations: {}
    # -- Service account which is used to run workflows
    name: "argo-workflow"
    # -- Secrets with credentials to pull images from a private registry. Same format as `.Values.images.pullSecrets`
    pullSecrets: []
  rbac:
    # -- Adds Role and RoleBinding for the above specified service account to be able to run workflows.
    # A Role and Rolebinding pair is also created for each namespace in controller.workflowNamespaces (see below)
    create: true

controller:
  image:
    # -- Registry to use for the controller
    registry: quay.io
    # -- Registry to use for the controller
    repository: argoproj/workflow-controller
    # -- Image tag for the workflow controller. Defaults to `.Values.images.tag`.
    tag: ""
  # -- parallelism dictates how many workflows can be running at the same time
  parallelism:
  # -- Globally limits the rate at which pods are created.
  # This is intended to mitigate flooding of the Kubernetes API server by workflows with a large amount of
  # parallel nodes.
  resourceRateLimit: {}
    # limit: 10
    # burst: 1

  rbac:
    # -- Adds Role and RoleBinding for the controller.
    create: true
    # -- Allows controller to get, list, and watch certain k8s secrets
    secretWhitelist: []
    # -- Allows controller to get, list and watch all k8s secrets. Can only be used if secretWhitelist is empty.
    accessAllSecrets: true
    # -- Allows controller to create and update ConfigMaps. Enables memoization feature
    writeConfigMaps: true

  configMap:
    # -- Create a ConfigMap for the controller
    create: true
    # -- ConfigMap name
    name: ""

  # -- Limits the maximum number of incomplete workflows in a namespace
  namespaceParallelism: 10
  # -- Resolves ongoing, uncommon AWS EKS bug: https://github.com/argoproj/argo-workflows/pull/4224
  initialDelay:
  # -- deploymentAnnotations is an optional map of annotations to be applied to the controller Deployment
  deploymentAnnotations: {}
  # -- podAnnotations is an optional map of annotations to be applied to the controller Pods
  podAnnotations: {}
  # -- Optional labels to add to the controller pods
  podLabels: {}
  # -- SecurityContext to set on the controller pods
  podSecurityContext: {}
  # podPortName: http
  metricsConfig:
    # -- Enables prometheus metrics server
    enabled: true
    # -- Path is the path where metrics are emitted. Must start with a "/".
    path: /metrics
    # -- Port is the port where metrics are emitted
    port: 9090
    # -- How often custom metrics are cleared from memory
    metricsTTL: ""
    # -- Flag that instructs prometheus to ignore metric emission errors.
    ignoreErrors: true
    # --  Flag that use a self-signed cert for TLS
    secure: false
    # -- Container metrics port name
    portName: metrics
    # -- Service metrics port
    servicePort: 8080
    # -- Service metrics port name
    servicePortName: metrics
    # -- ServiceMonitor relabel configs to apply to samples before scraping
    ## Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig
    relabelings: []
    # -- ServiceMonitor metric relabel configs to apply to samples before ingestion
    ## Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#endpoint
    metricRelabelings: []
    # -- ServiceMonitor will add labels from the service to the Prometheus metric
    ## Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#servicemonitorspec
    targetLabels: []
  # -- the controller container's securityContext
  securityContext:
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
  # -- enable Workflow Archive to store the status of workflows. Postgres and MySQL (>= 5.7.8) are available.
  ## Ref: https://argo-workflows.readthedocs.io/en/stable/workflow-archive/
  persistence:
    connectionPool:
      maxIdleConns: 100
      maxOpenConns: 0
      connMaxLifetime: 0s
    # save the entire workflow into etcd and DB
    nodeStatusOffLoad: true
    # enable archiving of old workflows
    archive: true
    archiveTTL: 7d
    postgresql:
      host: postgres
      port: 5432
      database: postgres
      tableName: argo_workflows
      # the database secrets must be in the same namespace of the controller
      userNameSecret:
        name: argo-postgres-config
        key: username
      passwordSecret:
        name: argo-postgres-config
        key: password
      ssl: true
      # sslMode must be one of: disable, require, verify-ca, verify-full
      # you can find more information about those ssl options here: https://godoc.org/github.com/lib/pq
      sslMode: disable
  # mysql:
  #   host: localhost
  #   port: 3306
  #   database: argo
  #   tableName: argo_workflows
  #   userNameSecret:
  #     name: argo-mysql-config
  #     key: username
  #   passwordSecret:
  #     name: argo-mysql-config
  #     key: password

  # -- Default values that will apply to all Workflows from this controller, unless overridden on the Workflow-level.
  # Only valid for 2.7+
  ## See more: https://argo-workflows.readthedocs.io/en/stable/default-workflow-specs/
  workflowDefaults:
    spec:
        # workflows must complete in 8h (28,800 seconds) or they will be terminated
        # https://argoproj.github.io/argo-workflows/cost-optimisation/#limit-the-total-number-of-workflows-and-pods
        activeDeadlineSeconds: 28800
        ttlStrategy:
          # Delete workflows after 12 hours of completion (43,200 seconds)
          # https://argoproj.github.io/argo-workflows/fields/#ttlstrategy
          secondsAfterCompletion: 43200
        #podGC:
          # https://argoproj.github.io/argo-workflows/fields/#podgc
          # Delete pods once the workflow that launches them completes successfully
          #strategy: OnWorkflowSuccess
  #   spec:
  #     ttlStrategy:
  #       secondsAfterCompletion: 84600
  #     # Ref: https://argo-workflows.readthedocs.io/en/stable/artifact-repository-ref/
  #     artifactRepositoryRef:
  #       configMap: my-artifact-repository # default is "artifact-repositories"
  #       key: v2-s3-artifact-repository # default can be set by the `workflows.argoproj.io/default-artifact-repository` annotation in config map.

  # -- Number of workflow workers
  workflowWorkers: # 32
  # -- Number of workflow TTL workers
  workflowTTLWorkers: # 4
  # -- Number of pod cleanup workers
  podCleanupWorkers: # 4
  # -- Number of cron workflow workers
  # Only valid for 3.5+
  cronWorkflowWorkers: # 8
  # -- Restricts the Workflows that the controller will process.
  # Only valid for 2.9+
  workflowRestrictions: {}
    # templateReferencing: Strict|Secure

  # telemetryConfig controls the path and port for prometheus telemetry. Telemetry is enabled and emitted in the same endpoint
  # as metrics by default, but can be overridden using this config.
  telemetryConfig:
    # -- Enables prometheus telemetry server
    enabled: true
    # -- telemetry path
    path: /telemetry
    # -- telemetry container port
    port: 8081
    # -- How often custom metrics are cleared from memory
    metricsTTL: ""
    # -- Flag that instructs prometheus to ignore metric emission errors.
    ignoreErrors: true
    # --  Flag that use a self-signed cert for TLS
    secure: false
    # -- telemetry service port
    servicePort: 8081
    # -- telemetry service port name
    servicePortName: telemetry
  serviceMonitor:
    # -- Enable a prometheus ServiceMonitor
    enabled: true
    # -- Prometheus ServiceMonitor labels
    additionalLabels:
      prometheus: main
    # -- Prometheus ServiceMonitor namespace
    namespace: "" # "monitoring"
  serviceAccount:
    # -- Create a service account for the controller
    create: true
    # -- Service account name
    name: ""
    # -- Labels applied to created service account
    labels: {}
    # -- Annotations applied to created service account
    annotations: {}

  # -- Workflow controller name string
  name: workflow-controller

  # -- Specify all namespaces where this workflow controller instance will manage
  # workflows. This controls where the service account and RBAC resources will
  # be created. Only valid when singleNamespace is false.
  workflowNamespaces:
    - default

  instanceID:
    # -- Configures the controller to filter workflow submissions
    # to only those which have a matching instanceID attribute.
    ## NOTE: If `instanceID.enabled` is set to `true` then either `instanceID.userReleaseName`
    ## or `instanceID.explicitID` must be defined.
    enabled: false
    # -- Use ReleaseName as instanceID
    useReleaseName: false
    # useReleaseName: true

    # -- Use a custom instanceID
    explicitID: ""
    # explicitID: unique-argo-controller-identifier

  logging:
    # -- Set the logging level (one of: `debug`, `info`, `warn`, `error`)
    level: debug
    # -- Set the glog logging level
    globallevel: "6"
    # -- Set the logging format (one of: `text`, `json`)
    format: "json"

  # -- Service type of the controller Service
  serviceType: ClusterIP
  # -- Annotations to be applied to the controller Service
  serviceAnnotations: {}
  # -- Optional labels to add to the controller Service
  serviceLabels: {}
  # -- Source ranges to allow access to service from. Only applies to service type `LoadBalancer`
  loadBalancerSourceRanges: []

  # -- Resource limits and requests for the controller
  resources: {}

  # -- Configure liveness [probe] for the controller
  # @default -- See [values.yaml]
  livenessProbe:
    httpGet:
      port: 6060
      path: /healthz
    failureThreshold: 3
    initialDelaySeconds: 90
    periodSeconds: 60
    timeoutSeconds: 30

  # -- Extra environment variables to provide to the controller container
  extraEnv:
  # https://github.com/argoproj/argo-workflows/issues/9324
  - name: LEADER_ELECTION_DISABLE
    value: "true"
    # - name: FOO
    #   value: "bar"

  # -- Extra arguments to be added to the controller
  extraArgs:
  - --verbose
  # - --workflow-workers
  # - "64"
  # - --workflow-ttl-workers
  # - "8"
  - --qps=300
  - --burst=450
  # -- Additional volume mounts to the controller main container
  volumeMounts: []
  # -- Additional volumes to the controller pod
  volumes: []
  # -- The number of controller pods to run
  replicas: 1
  # -- The number of revisions to keep.
  revisionHistoryLimit: 10

  pdb:
    # -- Configure [Pod Disruption Budget] for the controller pods
    enabled: false
    # minAvailable: 1
    # maxUnavailable: 1

  # -- [Node selector]
  nodeSelector:
    kubernetes.io/os: linux
  # -- [Tolerations] for use with node taints
  tolerations: []
  # -- Assign custom [affinity] rules
  affinity: {}

  # -- Assign custom [TopologySpreadConstraints] rules to the workflow controller
  ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  ## If labelSelector is left out, it will default to the labelSelector configuration of the deployment
  topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: topology.kubernetes.io/zone
  #   whenUnsatisfiable: DoNotSchedule

  # -- Leverage a PriorityClass to ensure your pods survive resource shortages.
  ## ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: "workflow-controller"

  # -- Configure Argo Server to show custom [links]
  ## Ref: https://argo-workflows.readthedocs.io/en/stable/links/
  links:
    - name: Workflow Link
      scope: workflow
      url: http://logging-facility?namespace=${metadata.namespace}&workflowName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Pod Link
      scope: pod
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Pod Logs Link
      scope: pod-logs
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Event Source Logs Link
      scope: event-source-logs
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Sensor Logs Link
      scope: sensor-logs
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Completed Workflows
      scope: workflow-list
      url: http://workflows?label=workflows.argoproj.io/completed=true

  # -- Configure Argo Server to show custom [columns]
  ## Ref: https://github.com/argoproj/argo-workflows/pull/10693
  columns:
    - name: Workflow Completed
      type: label
      key: workflows.argoproj.io/completed
  # -- Set ui navigation bar background color
  navColor: ""
  clusterWorkflowTemplates:
    # -- Create a ClusterRole and CRB for the controller to access ClusterWorkflowTemplates.
    enabled: true
  # -- Extra containers to be added to the controller deployment
  extraContainers: []

  # -- Enables init containers to be added to the controller deployment
  extraInitContainers: []

  # -- Workflow retention by number of workflows
  retentionPolicy:
    completed: 10
    failed: 3
    errored: 3

  # https://github.com/argoproj/argo-workflows/blob/222d53cdfbffb962763689f3d0ba6ac2814e32d0/docs/workflow-controller-configmap.yaml#L36-L42
  # Whether or not to emit events on node completion. These can take a up a lot of space in
  # k8s (typically etcd) resulting in errors when trying to create new events:
  # "Unable to create audit event: etcdserver: mvcc: database space exceeded"
  # This config item allows you to disable this.
  # (since v2.9)
  nodeEvents:
    # -- Enable to emit events on node completion.
    ## This can take up a lot of space in k8s (typically etcd) resulting in errors when trying to create new events:
    ## "Unable to create audit event: etcdserver: mvcc: database space exceeded"
    enabled: false

  # -- Configure when workflow controller runs in a different k8s cluster with the workflow workloads,
  # or needs to communicate with the k8s apiserver using an out-of-cluster kubeconfig secret.
  # @default -- `{}` (See [values.yaml])
  kubeConfig: {}
    # # name of the kubeconfig secret, may not be empty when kubeConfig specified
    # secretName: kubeconfig-secret
    # # key of the kubeconfig secret, may not be empty when kubeConfig specified
    # secretKey: kubeconfig
    # # mounting path of the kubeconfig secret, default to /kube/config
    # mountPath: /kubeconfig/mount/path
    # # volume name when mounting the secret, default to kubeconfig
    # volumeName: kube-config-volume

  # -- Specifies the duration in seconds before a terminating pod is forcefully killed. A zero value indicates that the pod will be forcefully terminated immediately.
  # @default -- `30` seconds (Kubernetes default)
  podGCGracePeriodSeconds:

  # -- The duration in seconds before the pods in the GC queue get deleted. A zero value indicates that the pods will be deleted immediately.
  # @default -- `5s` (Argo Workflows default)
  podGCDeleteDelayDuration: ""

# mainContainer adds default config for main container that could be overriden in workflows template
mainContainer:
  # -- imagePullPolicy to apply to Workflow main container. Defaults to `.Values.images.pullPolicy`.
  imagePullPolicy: ""
  # -- Resource limits and requests for the Workflow main container
  resources: {}
  # -- Adds environment variables for the Workflow main container
  env: []
  # -- Adds reference environment variables for the Workflow main container
  envFrom: []
  # -- sets security context for the Workflow main container
  securityContext: {}

# executor controls how the init and wait container should be customized
executor:
  image:
    # -- Registry to use for the Workflow Executors
    registry: quay.io
    # -- Repository to use for the Workflow Executors
    repository: argoproj/argoexec
    # -- Image tag for the workflow executor. Defaults to `.Values.images.tag`.
    tag: ""
    # -- Image PullPolicy to use for the Workflow Executors. Defaults to `.Values.images.pullPolicy`.
    pullPolicy: ""
  # -- Resource limits and requests for the Workflow Executors
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
  # -- Passes arguments to the executor processes
  args: []
  # -- Adds environment variables for the executor.
  env: []
  # -- sets security context for the executor container
  securityContext: {}

server:
  # -- Deploy the Argo Server
  enabled: true
  # -- Value for base href in index.html. Used if the server is running behind reverse proxy under subpath different from /.
  ## only updates base url of resources on client side,
  ## it's expected that a proxy server rewrites the request URL and gets rid of this prefix
  ## https://github.com/argoproj/argo-workflows/issues/716#issuecomment-433213190
  # -- Value for base href in index.html. Used if the server is running behind reverse proxy under subpath different from /.
  ## only updates base url of resources on client side,
  ## it's expected that a proxy server rewrites the request URL and gets rid of this prefix
  ## https://github.com/argoproj/argo-workflows/issues/716#issuecomment-433213190
  baseHref: /
  image:
    # -- Registry to use for the server
    registry: quay.io
    # -- Repository to use for the server
    repository: argoproj/argocli
    # -- Image tag for the Argo Workflows server. Defaults to `.Values.images.tag`.
    tag: ""
  # -- optional map of annotations to be applied to the ui Deployment
  deploymentAnnotations: {}
  # -- optional map of annotations to be applied to the ui Pods
  podAnnotations: {}
  # -- Optional labels to add to the UI pods
  podLabels: {}
  # -- SecurityContext to set on the server pods
  podSecurityContext: {}
  rbac:
    # -- Adds Role and RoleBinding for the server.
    create: true
  # -- Servers container-level security context
  securityContext:
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
  # -- Server name string
  name: server
  # -- Service type for server pods
  serviceType: ClusterIP
  # -- Service port for server
  servicePort: 2746
  # -- Service node port
  serviceNodePort: # 32746
  # -- Service port name
  servicePortName: "" # http

  # -- Mapping between IP and hostnames that will be injected as entries in the pod's hosts files
  hostAliases: []
  # - ip: 10.20.30.40
  #   hostnames:
  #   - git.myhostname

  serviceAccount:
    # -- Create a service account for the server
    create: true
    # -- Service account name
    name: ""
    # -- Labels applied to created service account
    labels: {}
    # -- Annotations applied to created service account
    annotations:
      # This service account identity is associated with admin permissions
      # across the entire cluster
      #
      # It needs to have the highest precedence to prevent other service account
      # identities from overriding it
      # The rule is an expression used to determine if this service account
      # should be used.
      # * `groups` - an array of the OIDC groups
      # * `iss` - the issuer ("argo-server")
      # * `sub` - the subject (typically the username)
      # Must evaluate to a boolean.
      # If you want an account to be the default to use, this rule can be "true".
      # Details of the expression language are available in
      # https://expr-lang.org/docs/language-definition.
      # workflows.argoproj.io/rbac-rule: "'admin' in groups"
      workflows.argoproj.io/rbac-rule: "true"
      # workflows.argoproj.io/rbac-rule: "'authors' in groups && email == 'kilgore@kilgore.trout'"
      # The precedence is used to determine which service account to use whe
      # Precedence is an integer. It may be negative. If omitted, it defaults to "0".
      # Numerically higher values have higher precedence (not lower, which maybe
      # counter-intuitive to you).
      # If two rules match and have the same precedence, then which one used will
      # be arbitrary.
      workflows.argoproj.io/rbac-rule-precedence: "100000"

  # -- Annotations to be applied to the UI Service
  serviceAnnotations: {}
  # -- Optional labels to add to the UI Service
  serviceLabels: {}
  # -- Static IP address to assign to loadBalancer service type `LoadBalancer`
  loadBalancerIP: ""
  # -- Source ranges to allow access to service from. Only applies to service type `LoadBalancer`
  loadBalancerSourceRanges: []
  # -- Resource limits and requests for the server
  resources: {}
  # -- The number of server pods to run
  replicas: 1
  # -- The number of revisions to keep.
  revisionHistoryLimit: 10
  ## Argo Server Horizontal Pod Autoscaler
  autoscaling:
    # -- Enable Horizontal Pod Autoscaler ([HPA]) for the Argo Server
    enabled: false
    # -- Minimum number of replicas for the Argo Server [HPA]
    minReplicas: 1
    # -- Maximum number of replicas for the Argo Server [HPA]
    maxReplicas: 5
    # -- Average CPU utilization percentage for the Argo Server [HPA]
    targetCPUUtilizationPercentage: 50
    # -- Average memory utilization percentage for the Argo Server [HPA]
    targetMemoryUtilizationPercentage: 50
    # -- Configures the scaling behavior of the target in both Up and Down directions.
    # This is only available on HPA apiVersion `autoscaling/v2beta2` and newer
    behavior: {}
      # scaleDown:
      #  stabilizationWindowSeconds: 300
      #  policies:
      #   - type: Pods
      #     value: 1
      #     periodSeconds: 180
      # scaleUp:
      #   stabilizationWindowSeconds: 300
      #   policies:
      #   - type: Pods
      #     value: 2
  pdb:
    # -- Configure [Pod Disruption Budget] for the server pods
    enabled: false
    # minAvailable: 1
    # maxUnavailable: 1

  # -- [Node selector]
  nodeSelector:
    kubernetes.io/os: linux

  # -- [Tolerations] for use with node taints
  tolerations: []

  # -- Assign custom [affinity] rules
  affinity: {}

  # -- Assign custom [TopologySpreadConstraints] rules to the argo server
  ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  ## If labelSelector is left out, it will default to the labelSelector configuration of the deployment
  topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: topology.kubernetes.io/zone
  #   whenUnsatisfiable: DoNotSchedule

  # -- Leverage a PriorityClass to ensure your pods survive resource shortages
  ## ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: "argo-server"

  # -- Run the argo server in "secure" mode. Configure this value instead of `--secure` in extraArgs.
  ## See the following documentation for more details on secure mode:
  ## https://argo-workflows.readthedocs.io/en/stable/tls/
  secure: false

  # -- Extra environment variables to provide to the argo-server container
  extraEnv:
  # SOURCE: https://argo-workflows.readthedocs.io/en/latest/argo-server-sso/#sso-rbac-namespace-delegation
  # SSO RBAC Namespace Delegation¶
  # v3.3 and after

  # You can optionally configure RBAC SSO per namespace. Typically, on organization has a Kubernetes cluster and a central team (the owner of the cluster) manages the cluster. Along with this, there are multiple namespaces which are owned by individual teams. This feature would help namespace owners to define RBAC for their own namespace.

  # The feature is currently in beta. To enable the feature, set env variable SSO_DELEGATE_RBAC_TO_NAMESPACE=true in your argo-server deployment.
  # - name: SSO_DELEGATE_RBAC_TO_NAMESPACE
  #   value: "true"
  - name: FIRST_TIME_USER_MODAL
    value: "false"
  - name: FEEDBACK_MODAL
    value: "false"
  - name: NEW_VERSION_MODAL
    value: "false"
    # - name: FOO
    #   value: "bar"

  # -- Deprecated; use server.authModes instead.
  authMode: ""

  # -- A list of supported authentication modes. Available values are `server`, `client`, or `sso`. If you provide sso, please configure `.Values.server.sso` as well.
  ## Ref: https://argo-workflows.readthedocs.io/en/stable/argo-server-auth-mode/
  authModes: ["sso", "client", "server"]

  # -- Extra arguments to provide to the Argo server binary.
  ## Ref: https://argo-workflows.readthedocs.io/en/stable/argo-server/#options
  extraArgs:
  # - --secure=false
  - --api-rate-limit
  - "8000"
  # - "8000"
  # -  --loglevel=debug

  logging:
    # -- Set the logging level (one of: `debug`, `info`, `warn`, `error`)
    level: debug
    # -- Set the glog logging level
    globallevel: "6"
    # -- Set the logging format (one of: `text`, `json`)
    format: "json"

  # -- Volume to be mounted in Pods for temporary files.
  tmpVolume:
    emptyDir: {}
  # -- Additional volume mounts to the server main container.
  volumeMounts: []
  # -- Additional volumes to the server pod.
  volumes: []

  ## Ingress configuration.
  # ref: https://kubernetes.io/docs/user-guide/ingress/
  ingress:
    # -- Enable an ingress resource
    enabled: true
    # -- Additional ingress annotations
    annotations:
      # https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/
      ingress.kubernetes.io/proxy-body-size: 100M
      # nginx.ingress.kubernetes.io/rewrite-target: /$2
      nginx.ingress.kubernetes.io/rewrite-target: /
      # nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      # nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
      # nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
      # nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
      nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
      # ingress.kubernetes.io/ssl-redirect: "false"
      # SOURCE: https://argo-cd.readthedocs.io/en/stable/operator-manual/ingress/
      # In order to expose the Argo CD API server with a single ingress rule and hostname, the nginx.ingress.kubernetes.io/ssl-passthrough annotation must be used to passthrough TLS connections and terminate TLS at the Argo CD API server.
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      nginx.ingress.kubernetes.io/ssl-passthrough: "true"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
    # -- Additional ingress labels
    labels: {}
    # -- Defines which ingress controller will implement the resource
    ingressClassName: "nginx"

    # -- List of ingress hosts
    ## Hostnames must be provided if Ingress is enabled.
    ## Secrets must be manually created in the namespace
    hosts:
      - argo.k8s.localhost
      # - argoworkflows.example.com

    # -- List of ingress paths
    paths:
      - /

    # -- Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`
    pathType: Prefix
    # -- Additional ingress paths
    extraPaths: []
      # # - path: /*
      # #   backend:
      # #     serviceName: ssl-redirect
      # #     servicePort: use-annotation
      # ## for Kubernetes >=1.19 (when "networking.k8s.io/v1" is used)
      # - path: /*
      #   pathType: Prefix
      #   backend:
      #     service:
      #       name: ssl-redirect
      #       port:
      #         name: use-annotation
      # - path: /(.*)
      #   pathType: Prefix
      #   backend:
      #     service:
      #       name: argo-workflows-server
      #       port:
      #         name: web

    # -- Ingress TLS configuration
    tls:
      - secretName: tls-secret
        hosts:
          - argo.k8s.localhost

  ## Create a Google Backendconfig  for use with the GKE Ingress Controller
  ## https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-configuration#configuring_ingress_features_through_backendconfig_parameters
  GKEbackendConfig:
    # -- Enable BackendConfig custom resource for Google Kubernetes Engine
    enabled: false
    # -- [BackendConfigSpec]
    spec: {}
  #  spec:
  #    iap:
  #      enabled: true
  #      oauthclientCredentials:
  #        secretName: argoworkflows-secret

  ## Create a Google Managed Certificate for use with the GKE Ingress Controller
  ## https://cloud.google.com/kubernetes-engine/docs/how-to/managed-certs
  GKEmanagedCertificate:
    # -- Enable ManagedCertificate custom resource for Google Kubernetes Engine.
    enabled: false
    # -- Domains for the Google Managed Certificate
    domains:
    - argoworkflows.example.com

  ## Create a Google FrontendConfig Custom Resource, for use with the GKE Ingress Controller
  ## https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#configuring_ingress_features_through_frontendconfig_parameters
  GKEfrontendConfig:
    # -- Enable FrontConfig custom resource for Google Kubernetes Engine
    enabled: false
    # -- [FrontendConfigSpec]
    spec: {}
  # spec:
  #   redirectToHttps:
  #     enabled: true
  #     responseCodeName: RESPONSE_CODE

  clusterWorkflowTemplates:
    # -- Create a ClusterRole and CRB for the server to access ClusterWorkflowTemplates.
    enabled: true
    # -- Give the server permissions to edit ClusterWorkflowTemplates.
    enableEditing: true

  # SSO configuration when SSO is specified as a server auth mode.
  sso:
    # -- Create SSO configuration. If you set `true` , please also set `.Values.server.authMode` as `sso`.
    enabled: true
    # -- The root URL of the OIDC identity provider
    issuer: http://dex:5556/dex
    clientId:
      # -- Name of secret to retrieve the app OIDC client ID
      name: argo-server-sso
      # -- Key of secret to retrieve the app OIDC client ID
      key: clientID
    clientSecret:
      # -- Name of a secret to retrieve the app OIDC client secret
      name: argo-server-sso
      # -- Key of a secret to retrieve the app OIDC client secret
      key: clientSecret
    # - The OIDC redirect URL. Should be in the form <argo-root-url>/oauth2/callback.
    # This is the redirect URL supplied to the provider (optional). It must
    # be in the form <argo-server-root-url>/oauth2/callback. It must be
    # browser-accessible. If omitted, will be automatically generated.
    redirectUrl: "http://argo.k8s.localhost/oauth2/callback"
    # redirectUrl: "http://localhost:8080/oauth2/callback"
    rbac:
      # -- Adds ServiceAccount Policy to server (Cluster)Role.
      enabled: true
    # -- Whitelist to allow server to fetch Secrets
    ## When present, restricts secrets the server can read to a given list.
    ## You can use it to restrict the server to only be able to access the
    ## service account token secrets that are associated with service accounts
    ## used for authorization.
      secretWhitelist: []
    # -- Scopes requested from the SSO ID provider
    ## The 'groups' scope requests group membership information, which is usually used for authorization decisions.
    # Additional scopes to request. Typically needed for SSO RBAC. >= v2.12
    scopes:
    - groups
    - email
    - profile
      # - groups
    # -- Define how long your login is valid for (in hours)
    ## If omitted, defaults to 10h.
    sessionExpiry: "240h"
    # -- Alternate root URLs that can be included for some OIDC providers
    issuerAlias: "http://dex:5556/dex"
    # -- Override claim name for OIDC groups
    customGroupClaimName: ""
    # -- Specify the user info endpoint that contains the groups claim
    ## Configure this if your OIDC provider provides groups information only using the user-info endpoint (e.g. Okta)
    userInfoPath: ""
    # -- Skip TLS verification for the HTTP client
    insecureSkipVerify: true
    # -- Filter the groups returned by the OIDC provider
    ## A logical "OR" is used between each regex in the list
    filterGroupsRegex: []
      # - ".*argo-wf.*"
      # - ".*argo-workflow.*"

  # -- Extra containers to be added to the server deployment
  extraContainers: []

  # -- Enables init containers to be added to the server deployment
  extraInitContainers: []

# -- Array of extra K8s manifests to deploy
extraObjects:
  # - apiVersion: secrets-store.csi.x-k8s.io/v1
  #   kind: SecretProviderClass
  #   metadata:
  #     name: argo-server-sso
  #   spec:
  #     provider: aws
  #     parameters:
  #       objects: |
  #         - objectName: "argo/server/sso"
  #           objectType: "secretsmanager"
  #           jmesPath:
  #               - path: "client_id"
  #                 objectAlias: "client_id"
  #               - path: "client_secret"
  #                 objectAlias: "client_secret"
  #     secretObjects:
  #     - data:
  #       - key: client_id
  #         objectName: client_id
  #       - key: client_secret
  #         objectName: client_secret
  #       secretName: argo-server-sso-secrets-store
  #       type: Opaque
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: user-admin-login
      namespace: argo
      annotations:
        # * `groups` - an array of the OIDC groups
        # * `iss` - the issuer ("argo-server")
        # * `sub` - the subject (typically the username)
        # https://github.com/expr-lang/expr/blob/master/docs/language-definition.md
        # workflows.argoproj.io/rbac-rule: "true"
        workflows.argoproj.io/rbac-rule: "'admin' in groups"
        # workflows.argoproj.io/rbac-rule: "'<group>' in groups"
        workflows.argoproj.io/rbac-rule-precedence: "1"
  - apiVersion: v1
    kind: Secret
    metadata:
      name: user-admin-login.service-account-token
      namespace: argo
      annotations:
        kubernetes.io/service-account.name: user-admin-login
    type: kubernetes.io/service-account-token

  # - apiVersion: v1
  #   kind: Secret
  #   metadata:
  #     labels:
  #       app: postgres
  #     name: argo-postgres-config
  #   stringData:
  #     password: password
  #     username: postgres
  #   type: Opaque
  - apiVersion: scheduling.k8s.io/v1
    kind: PriorityClass
    metadata:
      name: workflow-controller
    value: 1000000

  - apiVersion: scheduling.k8s.io/v1
    kind: PriorityClass
    metadata:
      name: argo-server
    value: 1000000

  - apiVersion: v1
    kind: Secret
    metadata:
      name: argo-server-sso
    stringData:
      clientID: argo-server
      clientSecret: ZXhhbXBsZS1hcHAtc2VjcmV0

  # - apiVersion: v1
  #   kind: Secret
  #   metadata:
  #     name: argo-workflows-webhook-clients
  #   stringData:
  #     bitbucket.org: |
  #       type: bitbucket
  #       secret: "my-uuid"
  #     bitbucketserver: |
  #       type: bitbucketserver
  #       secret: "shh!"
  #     github.com: |
  #       type: github
  #       secret: "shh!"
  #     gitlab.com: |-
  #       type: gitlab
  #       secret: "shh!"

  - apiVersion: v1
    kind: Secret
    metadata:
      annotations:
        kubernetes.io/service-account.name: default
      name: default.service-account-token
    type: kubernetes.io/service-account-token

  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: argo

  # This is necessary to allow any user to login into the Argo Workflows UI
  # but has no permissions attached to it.
  #
  # Without this, namespace RBAC delegation cannot provide users access to their
  # namespace:
  # https://argoproj.github.io/argo-workflows/argo-server-sso/#recommended-usage
  #
  # It needs to have the lowest precedence since it will match any user identity
  #
  # DO NOT ATTACH ANYTHING TO THIS SERVICEACCOUNT
  - apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: user-default-login
      namespace: argo
      annotations:
        workflows.argoproj.io/rbac-rule: "true"
        workflows.argoproj.io/rbac-rule-precedence: "-100000"

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      annotations:
        workflows.argoproj.io/description: |
          This is the minimum recommended permissions needed if you want to use the agent, e.g. for HTTP or plugin templates.

          If <= v3.2 you must replace `workflowtasksets/status` with `patch workflowtasksets`.
      name: agent
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - workflowtasksets
      verbs:
      - list
      - watch
    - apiGroups:
      - argoproj.io
      resources:
      - workflowtasksets/status
      verbs:
      - patch

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: argo-role
    rules:
    - apiGroups:
      - coordination.k8s.io
      resources:
      - leases
      verbs:
      - create
      - get
      - update
    - apiGroups:
      - batch
      resources:
      - jobs
      verbs:
      - "*"
    - apiGroups:
      - ""
      resources:
      - pods
      - pods/exec
      verbs:
      - create
      - get
      - list
      - watch
      - update
      - patch
      - delete
    - apiGroups:
      - ""
      resources:
      - configmaps
      verbs:
      - get
      - watch
      - list
    - apiGroups:
      - ""
      resources:
      - persistentvolumeclaims
      - persistentvolumeclaims/finalizers
      verbs:
      - create
      - update
      - delete
      - get
    - apiGroups:
      - argoproj.io
      resources:
      - workflows
      - workflows/finalizers
      - workflowtasksets
      - workflowtasksets/finalizers
      - workflowartifactgctasks
      verbs:
      - get
      - list
      - watch
      - update
      - patch
      - delete
      - create
    - apiGroups:
      - argoproj.io
      resources:
      - workflowtemplates
      - workflowtemplates/finalizers
      verbs:
      - get
      - list
      - watch
    - apiGroups:
      - argoproj.io
      resources:
      - workflowtaskresults
      verbs:
      - list
      - watch
      - deletecollection
      - create
      - patch
    - apiGroups:
      - ""
      resources:
      - serviceaccounts
      verbs:
      - get
      - list
    - apiGroups:
      - ""
      resources:
      - secrets
      verbs:
      - get
    - apiGroups:
      - argoproj.io
      resources:
      - cronworkflows
      - cronworkflows/finalizers
      verbs:
      - get
      - list
      - watch
      - update
      - patch
      - delete
    - apiGroups:
      - ""
      resources:
      - events
      verbs:
      - create
      - patch
    - apiGroups:
      - policy
      resources:
      - poddisruptionbudgets
      verbs:
      - create
      - get
      - delete

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: argo-server-role
    rules:
    - apiGroups:
      - ""
      resources:
      - configmaps
      verbs:
      - get
      - watch
      - list
    - apiGroups:
      - ""
      resources:
      - secrets
      verbs:
      - get
      - create
      - list
      - watch
    - apiGroups:
      - ""
      resources:
      - pods
      - pods/exec
      - pods/log
      verbs:
      - get
      - list
      - watch
      - delete
    - apiGroups:
      - ""
      resources:
      - events
      verbs:
      - watch
      - create
      - patch
    - apiGroups:
      - ""
      resources:
      - serviceaccounts
      verbs:
      - get
      - list
      - watch
    - apiGroups:
      - argoproj.io
      resources:
      - eventsources
      - sensors
      - workflows
      - workfloweventbindings
      - workflowtemplates
      - cronworkflows
      - cronworkflows/finalizers
      verbs:
      - create
      - get
      - list
      - watch
      - update
      - patch
      - delete

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      annotations:
        workflows.argoproj.io/description: |
          This is the minimum recommended permissions needed if you want to use artifact GC.
      name: artifactgc
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - workflowartifactgctasks
      verbs:
      - list
      - watch
    - apiGroups:
      - argoproj.io
      resources:
      - workflowartifactgctasks/status
      verbs:
      - patch

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      annotations:
        workflows.argoproj.io/description: |
          Recomended minimum permissions for the `emissary` executor.
      name: executor
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - workflowtaskresults
      verbs:
      - create
      - patch

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      annotations:
        workflows.argoproj.io/description: |
          This is an example of the permissions you would need if you wanted to use a resource template to create and manage
          other pods. The same pattern would be suitable for other resurces, e.g. a service
      name: pod-manager
    rules:
    - apiGroups:
      - ""
      resources:
      - pods
      verbs:
      - create
      - get
      - patch

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: submit-workflow-template
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - workfloweventbindings
      verbs:
      - list
    - apiGroups:
      - argoproj.io
      resources:
      - workflowtemplates
      verbs:
      - get
    - apiGroups:
      - argoproj.io
      resources:
      - workflows
      verbs:
      - create

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      annotations:
        workflows.argoproj.io/description: |
          This is an example of the permissions you would need if you wanted to use a resource template to create and manage
          other workflows. The same pattern would be suitable for other resurces, e.g. a service
      name: workflow-manager
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - workflows
      verbs:
      - create
      - get

    # This defines a ClusterRole used to provide READONLY access to all
    # resources in a client hub namespace when paired with a namespace
    # scoped role bindings.
    #
    # Note: This is adapted from the role used for the argo-server at
    # https://github.com/argoproj/argo-workflows/blob/16308fa6111b8c35aa4478b5a1e7c76fa1ffdf4e/manifests/cluster-install/argo-server-rbac/argo-server-clusterole.yaml
    # but will be scoped only to client hub namespaces via individual
    # role bindings and only contains READONLY actions
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: client-readonly-workflows-ui-sso-access-cluster-role
    rules:
      - apiGroups:
          - ""
        resources:
          - configmaps
        verbs:
          - get
          - watch
          - list
      - apiGroups:
          - ""
        resources:
          - pods
          - pods/exec
          - pods/log
        verbs:
          - get
          - list
          - watch
      - apiGroups:
          - ""
        resources:
          - events
        verbs:
          - watch
      - apiGroups:
          - ""
        resources:
          - secrets
        resourceNames:
          - argo-artifacts-creds
        verbs:
          - get
      - apiGroups:
          - ""
        resources:
          - serviceaccounts
        verbs:
          - get
          - list
      - apiGroups:
          - argoproj.io
        resources:
          - eventsources
          - sensors
          - workflows
          - workfloweventbindings
          - workflowtemplates
          - cronworkflows
        verbs:
          - get
          - list
          - watch
    # This defines a ClusterRole used to provide ADMIN access to all
    # resources in a client hub namespace when paired with a namespace
    # scoped role binding.
    #
    # Note: This is adapted from the role used for the argo-server at
    # https://github.com/argoproj/argo-workflows/blob/16308fa6111b8c35aa4478b5a1e7c76fa1ffdf4e/manifests/cluster-install/argo-server-rbac/argo-server-clusterole.yaml
    # but will be scoped only to client hub namespaces via individual
    # role bindings
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: client-admin-workflows-ui-sso-access-cluster-role
    rules:
      - apiGroups:
          - ""
        resources:
          - configmaps
        verbs:
          - get
          - watch
          - list
      - apiGroups:
          - ""
        resources:
          - pods
          - pods/exec
          - pods/log
        verbs:
          - get
          - list
          - watch
          - delete
      - apiGroups:
          - ""
        resources:
          - events
        verbs:
          - watch
          - create
          - patch
      - apiGroups:
          - ""
        resources:
          - secrets
        verbs:
          - get
      - apiGroups:
          - ""
        resources:
          - serviceaccounts
        verbs:
          - get
          - list
      - apiGroups:
          - argoproj.io
        resources:
          - eventsources
          - sensors
          - workflows
          - workfloweventbindings
          - workflowtemplates
          - cronworkflows
        verbs:
          - create
          - get
          - list
          - watch
          - update
          - patch
          - delete

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: argo-clusterworkflowtemplate-role
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - clusterworkflowtemplates
      - clusterworkflowtemplates/finalizers
      verbs:
      - get
      - list
      - watch

    # This cluster role allows access to objects like workflow
    # templates, pods etc that is running in client hub namespace.
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: argo-shared-workflow-trigger-role
    rules:
      - apiGroups:
          - argoproj.io
        resources:
          - workflowtemplates
          - workflowtemplates/finalizers
        verbs:
          - get
          - list
          - watch
      - apiGroups:
          - ""
        resources:
          - pods
        verbs:
          - get
          - watch
          # pod patch is used to annotate the step's outputs back
          # to controller (e.g. artifact location)
          - patch
      - apiGroups:
          - ""
        resources:
          - pods/log
        verbs:
          - get
          - watch
      - apiGroups:
          - ""
        resources:
          - pods/exec
        verbs:
          - create
      - apiGroups:
          - ""
        resources:
          - configmaps
        verbs:
          - create
          - get
          - update
      # This allows one workflow to create another.
      - apiGroups:
          - argoproj.io
        resources:
          - workflows
        verbs:
          - create
          - get
          - list
    # This defines a ClusterRole used to provide access to ClusterWorkflow
    # templates for sensors/workflows in client namespaces on the hub cluster
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: argo-shared-clusterworkflowtemplate-role
    rules:
      - apiGroups:
          - argoproj.io
        resources:
          - clusterworkflowtemplates
          - clusterworkflowtemplates/finalizers
        verbs:
          - get
    # This cluster role binding allows all the service accounts to
    # get access on cluster wide object such as cluster workflow
    # templates etc. These are mentioned in the cluster role
    # argo-shared-clusterworkflowtemplate-role
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: argo-shared-clusterworkflowtemplate-clusterrolebinding
    roleRef:
      kind: ClusterRole
      name: argo-shared-clusterworkflowtemplate-role
      apiGroup: rbac.authorization.k8s.io
    subjects:
      - kind: Group
        name: system:serviceaccounts
        apiGroup: rbac.authorization.k8s.io

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: argo-server-clusterworkflowtemplate-role
    rules:
    - apiGroups:
      - argoproj.io
      resources:
      - clusterworkflowtemplates
      - clusterworkflowtemplates/finalizers
      verbs:
      - create
      - delete
      - watch
      - get
      - list
      - watch

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: agent-default
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: agent
    subjects:
    - kind: ServiceAccount
      name: default

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: argo-binding
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: argo-role
    subjects:
    - kind: ServiceAccount
      name: argo

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: argo-server-binding
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: argo-server-role
    subjects:
    - kind: ServiceAccount
      name: argo-server

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: artifactgc-default
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: artifactgc
    subjects:
    - kind: ServiceAccount
      name: default

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: executor-default
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: executor
    subjects:
    - kind: ServiceAccount
      name: default

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: pod-manager-default
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: pod-manager
    subjects:
    - kind: ServiceAccount
      name: default

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: workflow-manager-default
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: workflow-manager
    subjects:
    - kind: ServiceAccount
      name: default

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: argo-clusterworkflowtemplate-role-binding
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: argo-clusterworkflowtemplate-role
    subjects:
    - kind: ServiceAccount
      name: argo
      namespace: argo

  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: argo-server-clusterworkflowtemplate-role-binding
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: argo-server-clusterworkflowtemplate-role
    subjects:
    - kind: ServiceAccount
      name: argo-server
      namespace: argo


# -- Use static credentials for S3 (eg. when not using AWS IRSA)
useStaticCredentials: true
artifactRepository:
  # -- Archive the main container logs as an artifact
  archiveLogs: true
  # -- Store artifact in a S3-compliant object store
  # @default -- See [values.yaml]
  s3:
    # Note the `key` attribute is not the actual secret, it's the PATH to
    # the contents in the associated secret, as defined by the `name` attribute.
    accessKeySecret:
      # name: "{{ .Release.Name }}-minio"
      name: my-minio-cred
      key: accesskey
    secretKeySecret:
      # name: "{{ .Release.Name }}-minio"
      name: my-minio-cred
      key: secretkey
    # insecure will disable TLS. Primarily used for minio installs not configured with TLS
    insecure: true
    bucket: my-bucket
    endpoint: minio:9000
    # region:
    # roleARN:
    # useSDKCreds: true
    encryptionOptions:
      enableEncryption: false
  # -- Store artifact in a GCS object store
  # @default -- `{}` (See [values.yaml])
  gcs: {}
    # bucket: <project>-argo
    # keyFormat: "{{ \"{{workflow.namespace}}/{{workflow.name}}/{{pod.name}}\" }}"
    # # serviceAccountKeySecret is a secret selector.
    # # It references the k8s secret named 'my-gcs-credentials'.
    # # This secret is expected to have have the key 'serviceAccountKey',
    # # containing the base64 encoded credentials
    # # to the bucket.
    # #
    # # If it's running on GKE and Workload Identity is used,
    # # serviceAccountKeySecret is not needed.
    # serviceAccountKeySecret:
    #   name: my-gcs-credentials
    #   key: serviceAccountKey
  # -- Store artifact in Azure Blob Storage
  # @default -- `{}` (See [values.yaml])
  azure: {}
    # endpoint: https://mystorageaccountname.blob.core.windows.net
    # container: my-container-name
    # blobNameFormat: path/in/container
    # # accountKeySecret is a secret selector.
    # # It references the k8s secret named 'my-azure-storage-credentials'.
    # # This secret is expected to have have the key 'account-access-key',
    # # containing the base64 encoded credentials to the storage account.
    # # If a managed identity has been assigned to the machines running the
    # # workflow (e.g., https://docs.microsoft.com/en-us/azure/aks/use-managed-identity)
    # # then accountKeySecret is not needed, and useSDKCreds should be
    # # set to true instead:
    # useSDKCreds: true
    # accountKeySecret:
    #   name: my-azure-storage-credentials
    #   key: account-access-key

# -- The section of custom artifact repository.
# Utilize a custom artifact repository that is not one of the current base ones (s3, gcs, azure)
customArtifactRepository: {}
# artifactory:
#   repoUrl: https://artifactory.example.com/raw
#   usernameSecret:
#     name: artifactory-creds
#     key: username
#   passwordSecret:
#     name: artifactory-creds
#     key: password

# -- The section of [artifact repository ref](https://argo-workflows.readthedocs.io/en/stable/artifact-repository-ref/).
# Each map key is the name of configmap
# @default -- `{}` (See [values.yaml])
artifactRepositoryRef:
  # # -- 1st ConfigMap
  # # If you want to use this config map by default, name it "artifact-repositories".
  # # Otherwise, you can provide a reference to a
  # # different config map in `artifactRepositoryRef.configMap`.
  artifact-repositories:
    # -- v3.0 and after - if you want to use a specific key, put that key into this annotation.
    annotations:
      workflows.argoproj.io/default-artifact-repository: default-v1-s3-artifact-repository
    # 1st data of configmap. See above artifactRepository or customArtifactRepository.
    default-v1-s3-artifact-repository:
      archiveLogs: true
      s3:
        bucket: my-bucket
        endpoint: minio:9000
        insecure: true
        accessKeySecret:
          name: my-minio-cred
          key: accesskey
        secretKeySecret:
          name: my-minio-cred
          key: secretkey
  #    # 2nd data
  #    oss-artifact-repository:
  #      archiveLogs: false
  #      oss:
  #        endpoint: http://oss-cn-zhangjiakou-internal.aliyuncs.com
  #        bucket: $mybucket
  #        # accessKeySecret and secretKeySecret are secret selectors.
  #        # It references the k8s secret named 'bucket-workflow-artifect-credentials'.
  #        # This secret is expected to have have the keys 'accessKey'
  #        # and 'secretKey', containing the base64 encoded credentials
  #        # to the bucket.
  #        accessKeySecret:
  #          name: $mybucket-credentials
  #          key: accessKey
  #        secretKeySecret:
  #          name: $mybucket-credentials
  #          key: secretKey
  # # 2nd ConfigMap
  # another-artifact-repositories:
  #   annotations:
  #     workflows.argoproj.io/default-artifact-repository: gcs
  #   gcs:
  #     bucket: my-bucket
  #     keyFormat: prefix/in/bucket/{{workflow.name}}/{{pod.name}}
  #     serviceAccountKeySecret:
  #       name: my-gcs-credentials
  #       key: serviceAccountKey

emissary:
  # -- The command/args for each image on workflow, needed when the command is not specified and the emissary executor is used.
  ## See more: https://argo-workflows.readthedocs.io/en/stable/workflow-executors/#emissary-emissary
  images:
      docker/whalesay:latest:
        cmd: [cowsay]
  #  argoproj/argosay:v2:
  #    cmd: [/argosay]
  #  docker/whalesay:latest:
  #    cmd: [/bin/bash]
